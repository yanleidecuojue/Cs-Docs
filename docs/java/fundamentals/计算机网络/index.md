#### HTTP 基本概念

**1.HTTP 是什么？**

```
1.HTTP是超文本传输协议(HyperText Transfer Protocol); HTTP是一个在计算机世界里专门在两点之间传输文字，图片，音频，视频等超文本数据的约定和规范
2.HTTP常见状态码
```

**2.HTTP 常见状态码有哪些？**

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/001.png)

```
1xx
1xx 类状态码属于提示信息,是协议处理中的一种中间状态,实际用到的比较少。
2xx
2xx 类状态码表示服务器成功处理了客户端的请求,也是我们最愿意看到的状态。
「200 OK」是最常见的成功状态码,表示一切正常。如果是非 HEAD 请求,服务器器返回的响应头都会有 body 数据。
「204 No Content」也是常见的成功状态码,与 200 OK 基本相同,但响应头没有 body 数据。
「206 Partial Content」是应用于 HTTP 分块下载或断点续传,表示响应返回的 body 数据并不不是资源的全部,而是其中的一部分,也是服务器处理成功的状态。
3xx
3xx 类状态码表示客户端请求的资源发生了变动,需要客户端用新的 URL 重新发送请求获取资源,也就是重定向。
「301 Moved Permanently」表示永久重定向,说明请求的资源已经不存在了,需改用新的 URL 再次访问。
「302 Found」表示临时重定向,说明请求的资源还在,但暂时需要用另一个 URL 来访问。
301 和 302 都会在响应头里里里使用用字段 Location ,指明后续要跳转的 URL,浏览器器会自自动重定向新的
URL。
「304 Not Modified」不具有跳转的含义,表示资源未修改,重定向已存在的缓冲文件,也称缓存重定向,用于缓存控制。
4xx
4xx 类状态码表示客户端发送的报文有误,服务器器无法处理,也就是错误码的含义。
「400 Bad Request」表示客户端请求的报文有错误,但只是个笼统的错误。
「403 Forbidden」表示服务器禁止访问资源,并不是客户端的请求出错。
「404 Not Found」表示请求的资源在服务器器上不存在或未找到,所以无法提供给客户端。
5xx
5xx 类状态码表示客户端请求报文正确,但是服务器处理时内部发生了错误,属于服务器端的错误
码。
「500 Internal Server Error」与 400 类型,是个笼统通用的错误码,服务器器发生了什么错误,我们并不知道。
「501 Not Implemented」表示客户端请求的功能还不不支持,类似“即将开业,敬请期待”的意思。
「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码,表示服务器自身工作正常,访问后端服务器发生了错误。
「503 Service Unavailable」表示服务器当前很忙,暂时无法响应服务器,类似“网络服务正忙,请稍后重试”的意思
```

**3.HTTP 常见字段有哪些？**

```
3.1.Host字段
客户端发送请求时，用于指定服务器的域名
Host: www.A.com
3.2.Content-Length字段(字节为单位)
服务器返回数据时的字段，表示本次回应的数据长度
Content-Length: 1000
3.3.Connection字段
Connection字段最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用
HTTP/1.1版本的默认连接都是持久连接，但为了兼容老版本的HTTP，需要指定Connection字段的值为Keep-Alive
Connection: keep-alive
3.4.Content-Type字段
Content-Type字段用于指定服务器回应时，告诉客户端，本次数据是什么格式
Content-Type: text/html;charset=utf-8
3.5.Content-Encoding字段
表示服务器返回的数据使用了什么压缩格式
Accept-Encoding: gzip,deflate
Content-Encoding: gzip
```

#### GET 与 POST

**GET 与 POST 区别**

```
1.GET与POST区别
简单来说，前者是获取服务器资源，后者是向服务器提交资源
安全与幂等: 安全是是否破坏服务器上的资源，幂等是多次提交结果是否是相同的
GET是安全且幂等，POST是不安全且不幂等
```

#### HTTP 特性

**1.HTTP 有哪些优点**

简单，灵活和易于扩展，应用广泛和跨平台

**2.HTTP 有哪些缺点**

无状态，明文传输(不安全)

**3.HTTP 的性能如何？**

早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握 ⼿），⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。 为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在 于减少了 TCP 连接的᯿复建⽴和断开所造成的额外开销，减轻了服务器端的负载。 持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。长连接允许发送管道请求

#### HTTP 与 HTTPS

**1.HTTP 与 HTTPS 有哪些区别**

HTTPS 加入了 SSL/TLS(Secure Sockets Layer 安全套接字协议,Transport Layer Security 安全传输层协议)安全协议，使得报文可以加密传输

HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三 次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。

HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443

HTTPS 协议需要向 CA（Certifi*ca*te Authority 证书权威机构）申请数字证书，来保证服务器的身份是可信的。

**2.HTTPS 解决了 HTTP 什么问题**

窃听风险，篡改风险，冒充风险

信息加密，校验机制，身份证书

**3.HTTPS 是如何解决 HTTP 不安全问题的**

混合加密实现信息地机密性，解决窃听风险

```
HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式：
在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。
在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。
对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。
⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速
度慢。
```

摘要算法实现完整性，解决篡改风险

```
客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成
密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带
的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。
```

服务器公钥放到数字证书中，解决冒充风险

```
客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。
这就存在些问题，如何保证公钥不被篡改和信任度？
所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字
证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。
```

**4.HTTP 是如何建立连接的？其间交互了什么**

SSL/TLS 协议基本流程： 客户端向服务器索要并验证服务器的公钥。 双⽅协商⽣产「会话秘钥」。 双⽅采⽤「会话秘钥」进⾏加密通信。 前两步也就是 SSL/TLS 的建⽴过程，也就是握⼿阶段。 SSL/TLS 的「握⼿阶段」涉及四次通信，可⻅下图：

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/002.png)

```
SSL/TLS 协议建⽴的详细流程：
1. ClientHello
⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。
在这⼀步，客户端主要向服务器发送以下信息：
（1）客户端⽀持的 SSL/TLS 协议版本，如 TLS 1.2 版本。
（2）客户端⽣产的随机数（ Client Random ），后⾯⽤于⽣产「会话秘钥」。
（3）客户端⽀持的密码套件列表，如 RSA 加密算法。
2. SeverHello
服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：
（1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。
（2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。
（3）确认的密码套件列表，如 RSA 加密算法。
（4）服务器的数字证书。
3.客户端回应
客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的
真实性。
如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如
下信息：
（1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。
（2）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。
（3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数
据做个摘要，⽤来供服务端校验。
上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着
就⽤双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」。
4. 服务器的最后回应
服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信
的「会话秘钥」。然后，向客户端发⽣最后的信息：
（1）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。
（2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数
据做个摘要，⽤来供客户端校验。
⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普
通的 HTTP 协议，只不过⽤「会话秘钥」加密内容。
```

#### HTTP/1.1,HTTP/2,HTTP/3

**1.HTTP/1.1 相比 HTTP/1.0 提高了什么性能**

使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。 ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出 去，可以减少整体的响应时间。 但 HTTP/1.1 还是有性能瓶颈： 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分； 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多； 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头 阻塞； 没有请求优先级控制； 请求只能从客户端开始，服务器只能被动响应。

**2.HTTP/2 针对 HTTP/1 做了哪些优化**

```
1. 头部压缩
HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会
帮你消除重复的部分。
这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣
成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。
2. ⼆进制格式
HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是
⼆进制，并且统称为帧（frame）：头信息帧和数据帧。
这样虽然对⼈不友好，但是对计算机⾮常友好，因为计算机只懂⼆进制，那么收到报⽂后，⽆需再将明
⽂的报⽂转成⼆进制，⽽是直接解析⼆进制报⽂，这增加了数据传输的效率。
3. 数据流
HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必
须要对数据包做标记，指出它属于哪个回应。
每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编
号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。
4. 多路复⽤
HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。
移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，
⼤幅度提⾼了连接的利⽤率。
举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。
5. 服务器推送
HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动
向客户端发送消息。
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给
客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。
```

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/003.png)

**3.HTTP/2 有哪些缺陷，HTTP/3 做了哪些优化**

HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的᯿传机制，这样在⼀个 TCP 连接中的所有 的 HTTP 请求都必须等待这个丢了的包被重传回来。 HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了 HTTP/2 多个请求复⽤⼀个 TCP 连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。 这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/004.png)

UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包全 部᯿传问题。 ⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。 QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他 流不会受到影响。 TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。 HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。 QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。

所以， QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复⽤的协议。 QUIC 是新协议，对于很多⽹络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问 题。所以 HTTP/3 现在普及的进度⾮常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。

#### IP 基本认识

**1.IP 的作用**

**2.IP 与 MAC 的关系**

源 IP 地址和⽬标 IP 地址在传输过程中是不会变化的，只有 源 MAC 地址和⽬标 MAC ⼀直在变化

#### IP 地址的基础知识

**1.IP 地址的定义**

**2.IP 地址的分类**

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/005.png)

在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。

主机号全为 1 指定某个⽹络下的所有主机，⽤于⼴播 主机号全为 0 指定某个⽹络

⼴播地址⽤于在同⼀个链路中相互连接的主机之间发送数据包。

```
⼴播地址可以分为本地⼴播和直接⼴播两种。
在本⽹络内⼴播的叫做本地⼴播。例如⽹络地址为 192.168.0.0/24 的情况下，⼴播地址是
192.168.0.255 。因为这个⼴播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的
其他链路上。
在不同⽹络之间的⼴播叫做直接⼴播。例如⽹络地址为 192.168.0.0/24 的主机向 192.168.1.255/24
的⽬标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从⽽使得所有
192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接⼴播有⼀定的安全问题，多数情况
下会在路由器上设置为不转发。）
```

```
多播⽤于将包发送给特定组内的所有主机。
还是举班级的栗⼦，⽼师说：“最后⼀排的同学，上来做这道数学题。”，⽼师指定的是最后⼀排的同
学，也就是多播的含义了。
由于⼴播⽆法穿透路由，若想给其他⽹段发送同样的包，就可以使⽤可以穿透路由的多播。

从 224.0.0.0 ~ 239.255.255.255 都是多播的可⽤范围，其划分为以下三类：
224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域⽹中，路由器是不会进⾏转发的。
224.0.1.0 ~ 238.255.255.255 为⽤户可⽤的组播地址，可以⽤于 Internet 上。
239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部⽹在内部使⽤，仅在特定的本地范围
内有效。
```

**3.无分类 IP 地址**

```
IP 分类的缺点
缺点⼀
同⼀⽹络下没有地址层次，⽐如⼀个公司⾥⽤了 B 类地址，但是可能需要根据⽣产环境、测试环境、开
发环境来划分地址层次，⽽这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。
缺点⼆
A、B、C类有个尴尬处境，就是不能很好的与现实⽹络匹配。
C 类地址能包含的最⼤主机数量实在太少了，只有 254 个，估计⼀个⽹吧都不够⽤。
⽽ B 类地址能包含的最⼤主机数量⼜太多了，6 万多台机器放在⼀个⽹络下⾯，⼀般的企业基本达
不到这个规模，闲着的地址就是浪费。
这两个缺点，都可以在 CIDR(Classless Inter-Domain Routing)⽆分类地址解决。
```

```
32 ⽐特的 IP 地址被划分为两部分，前⾯是⽹络号，后⾯是主机号。

表示形式 a.b.c.d/x ，其中 /x 表示前 x 位属于⽹络号， x 的范围是 0 ~ 32 ，这就使得 IP 地址更加具有灵活性
```

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/006.png)

还有另⼀种划分⽹络号与主机号形式，那就是⼦⽹掩码，掩码的意思就是掩盖掉主机号，剩余的就是⽹ 络号。 将⼦⽹掩码和 IP 地址按位计算 AND，就可得到⽹络号

为什么要分离⽹络号和主机号？ 因为两台计算机要通讯，⾸先要判断是否处于同⼀个⼴播域内，即⽹络地址是否相同。如果⽹络地址相 同，表明接受⽅在本⽹络上，那么可以把数据包直接发送到⽬标主机。 路由器寻址⼯作中，也就是通过这样的⽅式来找到对应的⽹络号的，进⽽把数据包转发给对应的⽹络 内。

在上⾯我们知道可以通过⼦⽹掩码划分出⽹络号和主机号，那实际上⼦⽹掩码还有⼀个作⽤，那就是划 分⼦⽹。

⼦⽹划分实际上是将主机地址分为两个部分：⼦⽹⽹络地址和⼦⽹主机地址。形式如下：

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/007.png)

**4.共有 IP 地址和私有 IP 地址**

```
私有 IP 地址通常是内部的 IT ⼈员管理，公有 IP 地址是由 ICANN 组织管理，中⽂叫「互联⽹名称与数 字地址分配机构」。

IANA 是 ICANN 的其中⼀个机构，它负责分配互联⽹ IP 地址，是按州的⽅式层层分配

其中，在中国是由 CNNIC 的机构进⾏管理，它是中国国内唯⼀指定的全局 IP 地址管理的组织。
```

**5.IP 地址与路由控制**

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/008.png)

计算机使⽤⼀个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是⼀个叫做 localhost 的主机名。使⽤这个 IP 或主机名时，数据包不会流向⽹络。

**6.IP 分片与重组**

```
每种数据链路的最⼤传输单元 MTU 都是不相同的，如 FDDI 数据链路 MTU 4352、以太⽹的 MTU 是
1500 字节等。
每种数据链路的 MTU 之所以不同，是因为每个不同类型的数据链路的使⽤⽬的不同。使⽤⽬的不同，
可承载的 MTU 也就不同。
其中，我们最常⻅数据链路是以太⽹，它的 MTU 是 1500 字节。
那么当 IP 数据包⼤⼩⼤于 MTU 时， IP 数据包就会被分⽚。经过分⽚之后的 IP 数据报在被᯿组的时候，只能由⽬标主机进⾏，路由器是不会进⾏᯿组的。
假设发送⽅发送⼀个 4000 字节的⼤数据报，若要传输在以太⽹链路，则需要把数据报分⽚成 3 个⼩数
据报进⾏传输，再交由接收⽅᯿组成⼤数据报。
```

```
在分⽚传输中，⼀旦某个分⽚丢失，则会造成整个 IP 数据报作废，所以 TCP 引⼊了 MSS(Maximum Segment Size) 也就是在
TCP 层进⾏分⽚不由 IP 层分⽚，那么对于 UDP 我们尽量不要发送⼀个⼤于 MTU 的数据报⽂。
```

**7.IPv6 基本认识**

```
IPv6 不仅仅只是可分配的地址变多了，它还有⾮常多的亮点。
IPv6 可⾃动配置，即使没有 DHCP 服务器也可以实现⾃动分配IP地址，真是便捷到即插即⽤啊。
IPv6 包头包⾸部⻓度采⽤固定的值 40 字节，去掉了包头校验和，简化了⾸部结构，减轻了路由器负荷，⼤⼤提⾼了传输的性能。
IPv6 有应对伪造 IP 地址的⽹络安全功能以及防⽌线路窃听的功能，⼤⼤提升了安全性。
```

IPv6 的地址主要有以下类型地址： 单播地址，⽤于⼀对⼀的通信 组播地址，⽤于⼀对多的通信 任播地址，⽤于通信最近的节点，最近的节点是由路由协议决定 没有⼴播地址

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/009.png)

对于⼀对⼀通信的 IPv6 地址，主要划分了三类单播地址，每类地址的有效范围都不同。 在同⼀链路单播通信，不经过路由器，可以使⽤链路本地单播地址，IPv4 没有此类型 在内⽹⾥单播通信，可以使⽤唯⼀本地地址，相当于 IPv4 的私有 IP 在互联⽹通信，可以使⽤全局单播地址，相当于 IPv4 的公有 IP

**8.IPv4 首部与 IPv6 首部**

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/010.png)

#### IP 协议相关技术

**1.DNS(domain name system)域名解析**

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/011.png)

```
浏览器⾸先看⼀下⾃⼰的缓存⾥有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析
⽂件 hosts ，如果还是没有，就会 DNS 服务器进⾏查询，查询的过程如下：
1. 客户端⾸先会发出⼀个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2. 本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 www.server.com，则它直接返回
IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“⽼⼤， 能告诉我 www.server.com 的
IP 地址吗？” 根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。
3. 根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com
区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 www.server.com 的 IP
地址吗？”
5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该
能问到”。
6. 本地 DNS 于是转向问权威 DNS 服务器：“⽼三，www.server.com对应的IP是啥呀？” server.com
的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接。
```

**2.ARP(Address Resolution Protocol)与 RARP 协议**

由于主机的路由表中可以找到下⼀跳的 IP 地址，所以可以通过 ARP 协议，求得下⼀跳的 MAC 地址。

主机会通过⼴播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中 的⽬标 IP 地址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ ARP 响应包返回给 主机。

ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。例如 将打印机服务器等⼩型嵌⼊式设备接⼊到⽹络时就经常会⽤得到。 通常这需要架设⼀台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这 个设备接⼊到⽹络，接着： 该设备会发送⼀条「我的 MAC 地址是 XXXX，请告诉我，我的 IP 地址应该是什么」的请求信息。 RARP 服务器接到这个消息后返回「MAC 地址为 XXXX 的设备，IP 地址为 XXXX」的信息给这个设 备。 最后，设备就根据从 RARP 服务器所收到的应答信息设置⾃⼰的 IP 地址。

**3.DHCP 动态获取 IP 地址**

```
先说明⼀点，DHCP 客户端进程监听的是 68 端⼝号，DHCP 服务端进程监听的是 67 端⼝号。
1.客户端⾸先发起 DHCP 发现报⽂（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使⽤的是 UDP ⼴播通信，其使⽤的⼴播⽬的地址是255.255.255.255（端⼝ 67） 并且使⽤ 0.0.0.0（端⼝ 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧⼴播到所有的⽹络中设备。
2.DHCP 服务器收到 DHCP 发现报⽂时，⽤ DHCP 提供报⽂（DHCP OFFER） 向客户端做出响应。该报⽂仍然使⽤ IP ⼴播地址 255.255.25 5.255，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、DNS 服务器以及 IP 地址租⽤期。
3.客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送DHCP 请求报⽂（DHCP REQUEST进⾏响应，回显配置的参数。
4.最后，服务端⽤ DHCP ACK 报⽂对 DHCP 请求报⽂进⾏响应，应答所要求的参数。⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租⽤期内使⽤ DHCP 服务器分配的IP 地址。
如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报⽂：服务器如果同意继续租⽤，则⽤ DHCP ACK 报⽂进⾏应答，客户端就会延⻓租期。服务器如果不同意继续租⽤，则⽤ DHCP NACK 报⽂，客户端就要停⽌使⽤租约的 IP 地址。
可以发现，DHCP 交互中，全程都是使⽤ UDP ⼴播通信。

如果 DHCP 服务器和客户端不是在同⼀个局域⽹内，路由器⼜不会转发⼴播包，那不是每个⽹络都要配⼀个 DHCP 服务器？
为了解决这⼀问题，就出现了 DHCP 中继代理。有了 DHCP 中继代理以后，对不同⽹段的 IP 地址分配也可以由⼀个 DHCP 服务器统⼀进⾏管理。
```

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/012.png)

DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，⽽ DHCP 中继代理在收到这个⼴播包以 后，再以单播的形式发给 DHCP 服务器。 服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包⼴播给 DHCP 客户端 。 因此，DHCP 服务器即使不在同⼀个链路上也可以实现统⼀分配和管理 IP 地址。

**4.NAT 网络地址转换**

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/013.png)

图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进⾏通信，并且这两 个客户端的本地端⼝都是 1025。 此时，两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端⼝号作为区分。 于是，⽣成⼀个 NAPT 路由器的转换表，就可以正确地转换地址跟端⼝的组合，令客户端 A、B 能同时 与服务器之间进⾏通信。 这种转换表在 NAT 路由器上⾃动⽣成。例如，在 TCP 的情况下，建⽴ TCP 连接⾸次握⼿时的 SYN 包 ⼀经发出，就会⽣成这个表。⽽后⼜随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。 NAT 那么⽜逼，难道就没缺点了吗？ 当然有缺陷，肯定没有⼗全⼗美的⽅案。 由于 NAT/NAPT 都依赖于⾃⼰的转换表，因此会有以下的问题： 外部⽆法主动与 NAT 内部服务器建⽴连接，因为 NAPT 转换表没有转换记录。 转换表的⽣成与转换操作都会产⽣性能开销。 通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。

如何解决 NAT 潜在的问题呢？ 解决的⽅法主要有两种⽅法。 第⼀种就是改⽤ IPv6 IPv6 可⽤范围⾮常⼤，以⾄于每台设备都可以配置⼀个公有 IP 地址，就不搞那么多花⾥胡哨的地址转换了，但是 IPv6 普及速度还需要⼀些时间。 第⼆种 NAT 穿透技术 NAT 穿越技术拥有这样的功能，它能够让⽹络应⽤程序主动发现⾃⼰位于 NAT 设备之后，并且会主动 获得 NAT 设备的公有 IP，并为⾃⼰建⽴端⼝映射条⽬，注意这些都是 NAT 设备后的应⽤程序⾃动完成 的。 也就是说，在 NAT 穿透技术中，NAT 设备后的应⽤程序处于主动地位，它已经明确地知道 NAT 设备要 修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建⽴好映射，这样就不像以前由 NAT 设备来建⽴映射了。 说⼈话，就是客户端主动从 NAT 设备获取公有 IP 地址，然后⾃⼰建⽴端⼝映射条⽬，然后⽤这个条⽬ 对外通信，就不需要 NAT 设备来进⾏转换了。

**5.ICMP 互联网控制报文协议**

ICMP 主要的功能包括：确认 IP 包是否成功送达⽬标地址、报告发送过程中 IP 包被废弃的原因和改善 ⽹络设置等。

在 IP 通信中如果某个 IP 包因为某种原因未能达到⽬标地址，那么这个具体的原因将由 ICMP 负责 通知。

ICMP ⼤致可以分为两⼤类：

⼀类是⽤于诊断的查询消息，也就是「查询报⽂类型」

另⼀类是通知出错原因的错误消息，也就是「差错报⽂类型」

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/014.png)

**6.IGMP 因特网组管理协议**

```
IGMP 是因特⽹组管理协议，⼯作在主机（组播成员）和最后⼀跳路由之间。
IGMP 报⽂向路由器申请加⼊和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除⾮主机通过 IGMP 加⼊到组播组，主机申请加⼊到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。
IGMP 报⽂采⽤ IP 封装，IP 头部的协议号为 2，⽽且 TTL 字段值通常为 1，因为 IGMP 是⼯作在主机与连接的路由器之间。
IGMP ⼯作机制
IGMP 分为了三个版本分别是，IGMPv1、IGMPv2、IGMPv3。
接下来，以 IGMPv2 作为例⼦，说说常规查询与响应和离开组播组这两个⼯作机制。
```

```
常规查询与响应⼯作机制:
1. 路由器会周期性发送⽬的地址为 224.0.0.1 （表示同⼀⽹段内所有主机和路由器） IGMP 常规查询报⽂。
2. 主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是0~10 秒，计时器超时后主机就会发送 IGMP 成员关系报告报⽂（源 IP 地址为⾃⼰主机的 IP 地址，⽬的 IP 地址为组播地址）。如果在定时器超时之前，收到同⼀个组内的其他主机发送的成员关系报告报⽂，则⾃⼰不再发送，这样可以减少⽹络中多余的 IGMP 报⽂数量。
3. 路由器收到主机的成员关系报⽂后，就会在 IGMP 路由表中加⼊该组播组，后续⽹络中⼀旦该组播
地址的数据到达路由器，它会把数据包转发出去。

离开组播组的情况⼀，⽹段中仍有该组播组：
1. 主机 1 要离开组 224.1.1.1，发送 IGMPv2 离组报⽂，报⽂的⽬的地址是 224.0.0.2（表示发向⽹段内的所有路由器）
2. 路由器 收到该报⽂后，以 1 秒为间隔连续发送 IGMP 特定组查询报⽂（共计发送 2 个），以便确认该⽹络是否还有 224.1.1.1 组的其他成员。
3. 主机 3 仍然是组 224.1.1.1 的成员，因此它⽴即响应这个特定组查询。路由器知道该⽹络中仍然存在该组播组的成员，于是继续向该⽹络转发 224.1.1.1 的组播数据包。

离开组播组的情况⼆，⽹段中没有该组播组：
1. 主机 1 要离开组播组 224.1.1.1，发送 IGMP 离组报⽂。
2. 路由器收到该报⽂后，以 1 秒为间隔连续发送 IGMP 特定组查询报⽂（共计发送 2 个）。此时在该⽹段内，组 224.1.1.1 已经没有其他成员了，因此没有主机响应这个查询。
3. ⼀定时间后，路由器认为该⽹段中已经没有 224.1.1.1 组播组成员了，将不会再向这个⽹段转发该组播地址的数据包。
```

#### ping 的工作原理

```
⽬标不可达类型的代码:
⽹络不可达代码为 0
主机不可达代码为 1
协议不可达代码为 2
端⼝不可达代码为 3
需要进⾏分⽚但设置了不分⽚位代码为 4
```

```
原点抑制消息（ICMP Source Quench Message） —— 类型 4
在使⽤低速⼴域线路的情况下，连接 WAN 的路由器可能会遇到⽹络拥堵的问题。ICMP 原点抑制消息的⽬的就是为了缓和这种拥堵情况。当路由器向低速线路发送数据时，其发送队列的缓存变为零⽽⽆法发送出去时，可以向 IP 包的源地址发送⼀个 ICMP 原点抑制消息。收到这个消息的主机借此了解在整个线路的某⼀处发⽣了拥堵的情况，从⽽增⼤ IP 包的传输间隔，减少⽹络拥堵的情况。然⽽，由于这种 ICMP 可能会引起不公平的⽹络通信，⼀般不被使⽤。
```

```
重定向消息（ICMP Redirect Message） —— 类型 5
如果路由器发现发送端主机使⽤了「不是最优」的路径发送数据，那么它会返回⼀个 ICMP 重定向消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发⽣在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外⼀个路由器。好⽐，⼩林本可以过条⻢路就能到的地⽅，但⼩林不知道，所以绕了⼀圈才到，后⾯⼩林知道后，下次⼩林就不会那么傻再绕⼀圈了。
```

```
IP 包中有⼀个字段叫做 TTL （ Time To Live ，⽣存周期），它的值随着每经过⼀次路由器就会减1，直到减到 0 时该 IP 包会被丢弃。
此时，路由器将会发送⼀个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。设置 IP 包⽣存周期的主要⽬的，是为了在路由控制遇到问题发⽣循环状况时，避免 IP 包⽆休⽌地在⽹络上被转发。
```

![](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/015.png)

```
说了这么多，可以看出 ping 这个程序是使⽤了 ICMP ⾥⾯的 ECHO REQUEST（类型为 8 ） 和ECHO REPLY （类型为 0）。
```

```
有⼀款充分利⽤ ICMP 差错报⽂类型的应⽤叫做 traceroute （在UNIX、MacOS中是这个命令，⽽在Windows中对等的命令叫做 tracert ）。
traceroute 作⽤
traceroute 的第⼀个作⽤就是故意设置特殊的 TTL，来追踪去往⽬的地时沿途经过的路由器。
traceroute 还有⼀个作⽤是故意设置不分⽚，从⽽确定路径的 MTU。
```

#### TCP三次握手与四次挥手

**1.TCP基本认识**

```
TCP头部格式
```

![image-20210506174544629](https://gitee.com/q14016070144/drawing-bed/raw/master/images/licona/code/computer-network/image-20210506174544629.png)

**2.TCP连接建立**

**3.TCP连接断开**

**4.Socket编程**

